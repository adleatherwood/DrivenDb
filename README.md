# DrivenDb

### Description

A better micro ORM designed for ease of use and performance with fewer round trips to the database.

# Welcome

DrivenDb is a database accessor in the micro ORM tradition. Database access made easier without compromising
performance with an emphasis on utilizing the database efficiently. Utilizing DrivenDb will result in minimal
overhead, cleaner code, and fewer round trips to the database than when using other ORMs.

## Latest Additions

* Added partial before/after methods for property setters and serialization.
* Added option to script "Unspecified" DateTime values into the property setters.

Go to the [How To](How To) for more information.

## Goals / Features

* Standard micro ORM features
 * Simplicity
 * Low overhead
 * Speed (For those who feel the need for it)
 * Less extraneous coding
* Improved micro ORM features
 * Reduced traffic to the database
 * Self tracking entities monitor changes made to the entity and it's current state.
 * Entity generator included for several popular databases** Entity generator included for several popular databases.
  * Provide a custom implementation for an unsupported database.
* Detailed change events for inserts, updates, and deletes (.net events / not triggers).

## Philosophy

* You write your own selects. You can include as many or as few fields in your result set as you like. You are not hindered by any kind of SQL translated wrapper classes or methods* You write your own selects. You can include as many or as few fields in your result set as you like. You are not hindered by any kind of SQL translated wrapper classes or methods.
* Only the most banal SQL is written for you. (e.g. selects, updates, and deletes on a primary key)
* Batch reads and writes to the database are more efficient. All entities inherit from the same base class. Pass an entire list of them to the database at once. All inserts, updates, and deletes are executed at once within a transaction.

# How To

Below is a list of features with an example for each.  They are basic, but to the point.

**Create an Accessor**

```c#
    var accessor = DbFactory.CreateAccessor(
        DbAccessorType.MsSql, 
        AccessorExtension.All,
        () => new SqlConnection(CSTRING)
        );
```

**Read a Single Value**

```c#
var value = accessor.ReadValue<long>("SELECT 7");
```

**Read an Array of Value*Read an Array of Values**

```c#
var ids = accessor.ReadValues<long>("SELECT [Id] FROM [Thing1]");
```

**Read Single Entity**

```c#
var thing1 = accessor.ReadEntity<Thing1>("SELECT * FROM [Thing1] WHERE Id = @0", 1);
```

**Read Multiple Entities**

```c#
var thing1s = accessor.ReadEntities<Thing1>("SELECT * FROM [Thing1]");
```

**Read Multiple Entities using Parallel Mapping**

```c#
var thing1s = accessor.Parallel.ReadEntities<Thing1>("SELECT * FROM [Thing1]");
```

**Read Single Entity by It's Primary Key**

```c#
var thing1 = accessor.ReadIdentity<Thing1, int>(1);
var thing2 = accessor.ReadIdentity<Thing2, int, int>(1, 2);
```

**Read Multiple Types of Multiple Entities**

```c#
var entities = accessor.ReadEntities<Thing1, Thing2>(
    @"SELECT * FROM [Thing1] WHERE [Id] = @0;
      SELECT * FROM [Thing2] WHERE [Thing1Id] = @0;",
      1);
```

**Read Anonymous Types**

```c#
var anon1s = accessor.ReadAnonymous(new { Id = 0L, Name = "", Value = 0L },
    "SELECT * FROM [Thing1]");
```	

**Read Any Type of Class**

```c#
var types = accessor.ReadType<Thing1>("SELECT * FROM [Thing1]");
```

**Read "Related" Entities**

```c#
var thing1 = accessor.ReadIdentity<Thing1, int>(1);
var thing2s = accessor.ReadRelated<Thing1, Thing2>(thing1)
    .On(t1 => new { t1.Id }, t2 => new { t2.Thing1Id });
```

**Execute SQL**

    accessor.Execute("DELETE FROM [Thing2] WHERE [Id] > @0", 50);

**Write Multiple Entities (Even Multiple Types)**

```c#
var thing2s = accessor
    .ReadEntities<Thing2>("SELECT * FROM [Thing2]")
    .ToList();
  
thing2s[0].Value = "one";     // update
thing2s[2].Entity.Delete();   // delete

// insert
var gnu2 = new Thing2() { Thing1Id = 1, Name = "New Thing 2", Value = "Priceless" };

thing2s.Add(gnu2);

// this is done within a transaction in one trip, all writes rollback on error
accessor.WriteEntities(thing2saccessor.WriteEntities(thing2s);

// the id has been updated wit the one generated by the d// the id has been updated wit the one generated by the db
Console.WriteLine("Gnu2 Id = '{0}'", gnu2.Id); 
```

**Register for Accessor Database Events**

```c#
DbChangeEventArgs includes the table name, columns, and the entity affected
```

**Write Entities within a Transaction**

```c#
var thing2s = accessor
    .ReadEntities<Thing2>("SELECT * FROM [Thing2]")
    .ToList();
  
thing2s[0].Value = "one";     // update
thing2s[2].Entity.Delete();   // delete

    // insert
var gnu2 = new Thing2() { Thing1Id = 1, Name = "New Thing 2", Value = "Priceless" };

thing2s.Add(gnu2);

using (var scope = accessor.CreateScope())
{
   scope.WriteEntity(thing2s[0]);
   scope.WriteEntity(thing2s[1]);
   scope.WriteEntity(gnu2);
   scope.Commit();   
}
```

Special thanks to: 

![JetBrains](https://www.jetbrains.com/company/docs/logo_jetbrains.png)

![ReSharper](https://www.jetbrains.com/resharper/docs/logo_resharper.png)
 
